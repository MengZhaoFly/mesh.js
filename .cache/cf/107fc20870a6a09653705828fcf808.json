{"id":"../src/shader-cloud.frag","dependencies":[{"name":"/Users/bytedance/Downloads/pre-work/mesh.js/.babelrc","includedInParent":true,"mtime":1623934807951},{"name":"/Users/bytedance/Downloads/pre-work/mesh.js/package.json","includedInParent":true,"mtime":1623935384483},{"name":"gl-matrix","parent":"/Users/bytedance/Downloads/pre-work/mesh.js/src/shader-cloud.frag","resolved":"/Users/bytedance/Downloads/pre-work/mesh.js/node_modules/gl-matrix/esm/index.js"}],"generated":{"js":"require(\"gl-matrix\").glMatrix.setMatrixArrayType(Array);\n\nmodule.exports = \"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec4 vColor;\\nvarying float flagBackground;\\n\\n#ifdef TEXTURE\\nvarying float frameIndex;\\nvarying vec3 vTextureCoord;\\nvarying vec4 vSourceRect;\\n#endif\\n\\n#ifdef CLIPPATH\\nvarying vec2 vClipUV;\\n#endif\\n\\n#ifdef FILTER\\nuniform int u_filterFlag;\\nuniform float u_colorMatrix[20];\\n#endif\\n\\n#ifdef CLOUDFILTER\\nvarying vec4 colorCloud0;\\nvarying vec4 colorCloud1;\\nvarying vec4 colorCloud2;\\nvarying vec4 colorCloud3;\\nvarying vec4 colorCloud4;\\n#endif\\n\\n#ifdef GRADIENT\\nvarying vec3 vGradientVector1;\\nvarying vec3 vGradientVector2;\\nuniform float u_colorSteps[40];\\nuniform int u_gradientType;\\n\\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\\n  float t;\\n  // center circle radius\\n  float cr = gv1.z;\\n  // focal circle radius\\n  float fr = gv2.z;\\n\\n  if(cr > 0.0 || fr > 0.0) {\\n    // radial gradient\\n    vec2 center = gv1.xy;\\n    vec2 focal = gv2.xy;\\n    float x = focal.x - gl_FragCoord.x;\\n    float y = focal.y - gl_FragCoord.y;\\n    float dx = focal.x - center.x;\\n    float dy = focal.y - center.y;\\n    float dr = cr - fr;\\n    float a = dx * dx + dy * dy - dr * dr;\\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\\n    float c = x * x + y * y - fr * fr;\\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\\n  } else {\\n    // linear gradient\\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\\n    vec2 v2 = gv2.xy - gv1.xy;\\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\\n  }\\n\\n  vec4 colors[8];\\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\\n  \\n  float steps[8];\\n  steps[0] = colorSteps[0];\\n  steps[1] = colorSteps[5];\\n  steps[2] = colorSteps[10];\\n  steps[3] = colorSteps[15];\\n  steps[4] = colorSteps[20];\\n  steps[5] = colorSteps[25];\\n  steps[6] = colorSteps[30];\\n  steps[7] = colorSteps[35];\\n\\n  color = colors[0];\\n  for (int i = 1; i < 8; i++) {\\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\\n      break;\\n    }\\n    if(steps[i] == steps[i - 1]) {\\n      color = colors[i];\\n    } else {\\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\\n    }\\n    if (steps[i] >= t) {\\n      break;\\n    }\\n  }\\n}\\n#endif\\n\\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\\n  float r = color.r, g = color.g, b = color.b, a = color.a;\\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\\n}\\n\\n#ifdef CLOUDFILTER\\nvoid buildCloudColor(inout float colorCloudMatrix[20]) {\\n  colorCloudMatrix[0] = colorCloud0[0];\\n  colorCloudMatrix[1] = colorCloud1[0];\\n  colorCloudMatrix[2] = colorCloud2[0];\\n  colorCloudMatrix[3] = colorCloud3[0];\\n  colorCloudMatrix[4] = colorCloud4[0];\\n\\n  colorCloudMatrix[5] = colorCloud0[1];\\n  colorCloudMatrix[6] = colorCloud1[1];\\n  colorCloudMatrix[7] = colorCloud2[1];\\n  colorCloudMatrix[8] = colorCloud3[1];\\n  colorCloudMatrix[9] = colorCloud4[1];\\n\\n  colorCloudMatrix[10] = colorCloud0[2];\\n  colorCloudMatrix[11] = colorCloud1[2];\\n  colorCloudMatrix[12] = colorCloud2[2];\\n  colorCloudMatrix[13] = colorCloud3[2];\\n  colorCloudMatrix[14] = colorCloud4[2];\\n\\n  colorCloudMatrix[15] = colorCloud0[3];\\n  colorCloudMatrix[16] = colorCloud1[3];\\n  colorCloudMatrix[17] = colorCloud2[3];\\n  colorCloudMatrix[18] = colorCloud3[3];\\n  colorCloudMatrix[19] = colorCloud4[3];\\n}\\n#endif\\n\\nvoid main() {\\n  vec4 color = vColor;\\n  float opacity = abs(flagBackground);\\n\\n#ifdef GRADIENT\\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\\n  }\\n#endif\\n\\n  if(opacity < 1.0) {\\n    color.a *= opacity;\\n  }\\n\\n#ifdef TEXTURE\\n  if(flagBackground > 0.0) {\\n    vec3 texCoord = vTextureCoord;\\n\\n    if(texCoord.z == 1.0) {\\n      texCoord = fract(texCoord);\\n    }\\n\\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\\n      if(vSourceRect.z > 0.0) {\\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\\n      }\\n      if(frameIndex < 0.0) {\\n        vec4 texColor = texture2D(u_texSampler, texCoord.xy);\\n        color = mix(color, texColor, texColor.a);\\n      } else {\\n        int index = int(floor(clamp(0.0, 11.0, frameIndex)));\\n        vec4 texColor;\\n        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);\\n        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);\\n        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);\\n        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);\\n        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);\\n        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);\\n        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);\\n        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);\\n        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);\\n        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);\\n        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);\\n        else texColor = texture2D(u_texFrame11, texCoord.xy);\\n        float alpha = texColor.a;\\n        if(opacity < 1.0) {\\n          texColor.a *= opacity;\\n          alpha *= mix(0.465, 1.0, opacity);\\n        }\\n        // color = mix(color, texColor, texColor.a);\\n        color.rgb = mix(color.rgb, texColor.rgb, alpha);\\n        // color.rgb = mix(texColor.rgb, color.rgb, color.a);\\n        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\\n        color.a = texColor.a + (1.0 - texColor.a) * color.a;\\n      }\\n    }\\n  }\\n#endif\\n\\n#ifdef FILTER\\n  if(u_filterFlag > 0) {\\n    transformColor(color, u_colorMatrix);\\n  }\\n#endif\\n\\n#ifdef CLOUDFILTER\\n  float colorCloudMatrix[20];\\n  buildCloudColor(colorCloudMatrix);\\n  transformColor(color, colorCloudMatrix);\\n#endif\\n\\n#ifdef CLIPPATH\\n  float clip = texture2D(u_clipSampler, vClipUV).r;\\n  color *= clip;\\n#endif\\n\\n  gl_FragColor = color;\\n}\";"},"sourceMaps":{"js":{"mappings":[{"name":"module","generated":{"line":3,"column":0},"source":"../src/shader-cloud.frag","original":{"line":1,"column":0}},{"generated":{"line":3,"column":6},"source":"../src/shader-cloud.frag","original":{"line":1,"column":6}},{"name":"exports","generated":{"line":3,"column":7},"source":"../src/shader-cloud.frag","original":{"line":1,"column":7}},{"generated":{"line":3,"column":14},"source":"../src/shader-cloud.frag","original":{"line":1,"column":0}},{"generated":{"line":3,"column":17},"source":"../src/shader-cloud.frag","original":{"line":1,"column":15}},{"generated":{"line":3,"column":7218},"source":"../src/shader-cloud.frag","original":{"line":1,"column":0}}],"sources":{"../src/shader-cloud.frag":"module.exports=\"precision mediump float;\\n#define GLSLIFY 1\\n\\nvarying vec4 vColor;\\nvarying float flagBackground;\\n\\n#ifdef TEXTURE\\nvarying float frameIndex;\\nvarying vec3 vTextureCoord;\\nvarying vec4 vSourceRect;\\n#endif\\n\\n#ifdef CLIPPATH\\nvarying vec2 vClipUV;\\n#endif\\n\\n#ifdef FILTER\\nuniform int u_filterFlag;\\nuniform float u_colorMatrix[20];\\n#endif\\n\\n#ifdef CLOUDFILTER\\nvarying vec4 colorCloud0;\\nvarying vec4 colorCloud1;\\nvarying vec4 colorCloud2;\\nvarying vec4 colorCloud3;\\nvarying vec4 colorCloud4;\\n#endif\\n\\n#ifdef GRADIENT\\nvarying vec3 vGradientVector1;\\nvarying vec3 vGradientVector2;\\nuniform float u_colorSteps[40];\\nuniform int u_gradientType;\\n\\nvoid gradient(inout vec4 color, vec3 gv1, vec3 gv2, float colorSteps[40]) {\\n  float t;\\n  // center circle radius\\n  float cr = gv1.z;\\n  // focal circle radius\\n  float fr = gv2.z;\\n\\n  if(cr > 0.0 || fr > 0.0) {\\n    // radial gradient\\n    vec2 center = gv1.xy;\\n    vec2 focal = gv2.xy;\\n    float x = focal.x - gl_FragCoord.x;\\n    float y = focal.y - gl_FragCoord.y;\\n    float dx = focal.x - center.x;\\n    float dy = focal.y - center.y;\\n    float dr = cr - fr;\\n    float a = dx * dx + dy * dy - dr * dr;\\n    float b = -2.0 * (y * dy + x * dx + fr * dr);\\n    float c = x * x + y * y - fr * fr;\\n    t = 1.0 - 0.5 * (1.0 / a) * (-b + sqrt(b * b - 4.0 * a * c));\\n  } else {\\n    // linear gradient\\n    vec2 v1 = gl_FragCoord.xy - gv1.xy;\\n    vec2 v2 = gv2.xy - gv1.xy;\\n    t = (v1.x * v2.x + v1.y * v2.y) / (v2.x * v2.x + v2.y * v2.y);\\n  }\\n\\n  vec4 colors[8];\\n  colors[0] = vec4(colorSteps[1], colorSteps[2], colorSteps[3], colorSteps[4]);\\n  colors[1] = vec4(colorSteps[6], colorSteps[7], colorSteps[8], colorSteps[9]);\\n  colors[2] = vec4(colorSteps[11], colorSteps[12], colorSteps[13], colorSteps[14]);\\n  colors[3] = vec4(colorSteps[16], colorSteps[17], colorSteps[18], colorSteps[19]);\\n  colors[4] = vec4(colorSteps[21], colorSteps[22], colorSteps[23], colorSteps[24]);\\n  colors[5] = vec4(colorSteps[26], colorSteps[27], colorSteps[28], colorSteps[29]);\\n  colors[6] = vec4(colorSteps[31], colorSteps[32], colorSteps[33], colorSteps[34]);\\n  colors[7] = vec4(colorSteps[36], colorSteps[37], colorSteps[38], colorSteps[39]);\\n  \\n  float steps[8];\\n  steps[0] = colorSteps[0];\\n  steps[1] = colorSteps[5];\\n  steps[2] = colorSteps[10];\\n  steps[3] = colorSteps[15];\\n  steps[4] = colorSteps[20];\\n  steps[5] = colorSteps[25];\\n  steps[6] = colorSteps[30];\\n  steps[7] = colorSteps[35];\\n\\n  color = colors[0];\\n  for (int i = 1; i < 8; i++) {\\n    if (steps[i] < 0.0 || steps[i] > 1.0) {\\n      break;\\n    }\\n    if(steps[i] == steps[i - 1]) {\\n      color = colors[i];\\n    } else {\\n      color = mix(color, colors[i], clamp((t - steps[i - 1]) / (steps[i] - steps[i - 1]), 0.0, 1.0));\\n    }\\n    if (steps[i] >= t) {\\n      break;\\n    }\\n  }\\n}\\n#endif\\n\\nvoid transformColor(inout vec4 color, in float colorMatrix[20]) {\\n  float r = color.r, g = color.g, b = color.b, a = color.a;\\n  color[0] = colorMatrix[0] * r + colorMatrix[1] * g + colorMatrix[2] * b + colorMatrix[3] * a + colorMatrix[4];\\n  color[1] = colorMatrix[5] * r + colorMatrix[6] * g + colorMatrix[7] * b + colorMatrix[8] * a + colorMatrix[9];\\n  color[2] = colorMatrix[10] * r + colorMatrix[11] * g + colorMatrix[12] * b + colorMatrix[13] * a + colorMatrix[14];\\n  color[3] = colorMatrix[15] * r + colorMatrix[16] * g + colorMatrix[17] * b + colorMatrix[18] * a + colorMatrix[19];\\n}\\n\\n#ifdef CLOUDFILTER\\nvoid buildCloudColor(inout float colorCloudMatrix[20]) {\\n  colorCloudMatrix[0] = colorCloud0[0];\\n  colorCloudMatrix[1] = colorCloud1[0];\\n  colorCloudMatrix[2] = colorCloud2[0];\\n  colorCloudMatrix[3] = colorCloud3[0];\\n  colorCloudMatrix[4] = colorCloud4[0];\\n\\n  colorCloudMatrix[5] = colorCloud0[1];\\n  colorCloudMatrix[6] = colorCloud1[1];\\n  colorCloudMatrix[7] = colorCloud2[1];\\n  colorCloudMatrix[8] = colorCloud3[1];\\n  colorCloudMatrix[9] = colorCloud4[1];\\n\\n  colorCloudMatrix[10] = colorCloud0[2];\\n  colorCloudMatrix[11] = colorCloud1[2];\\n  colorCloudMatrix[12] = colorCloud2[2];\\n  colorCloudMatrix[13] = colorCloud3[2];\\n  colorCloudMatrix[14] = colorCloud4[2];\\n\\n  colorCloudMatrix[15] = colorCloud0[3];\\n  colorCloudMatrix[16] = colorCloud1[3];\\n  colorCloudMatrix[17] = colorCloud2[3];\\n  colorCloudMatrix[18] = colorCloud3[3];\\n  colorCloudMatrix[19] = colorCloud4[3];\\n}\\n#endif\\n\\nvoid main() {\\n  vec4 color = vColor;\\n  float opacity = abs(flagBackground);\\n\\n#ifdef GRADIENT\\n  if(u_gradientType > 0 && flagBackground > 0.0 || u_gradientType == 0 && flagBackground <= 0.0) {\\n    gradient(color, vGradientVector1, vGradientVector2, u_colorSteps);\\n  }\\n#endif\\n\\n  if(opacity < 1.0) {\\n    color.a *= opacity;\\n  }\\n\\n#ifdef TEXTURE\\n  if(flagBackground > 0.0) {\\n    vec3 texCoord = vTextureCoord;\\n\\n    if(texCoord.z == 1.0) {\\n      texCoord = fract(texCoord);\\n    }\\n\\n    if(texCoord.x <= 1.0 && texCoord.x >= 0.0\\n      && texCoord.y <= 1.0 && texCoord.y >= 0.0) {\\n      if(vSourceRect.z > 0.0) {\\n        texCoord.x = vSourceRect.x + texCoord.x * vSourceRect.z;\\n        texCoord.y = 1.0 - (vSourceRect.y + (1.0 - texCoord.y) * vSourceRect.w);\\n      }\\n      if(frameIndex < 0.0) {\\n        vec4 texColor = texture2D(u_texSampler, texCoord.xy);\\n        color = mix(color, texColor, texColor.a);\\n      } else {\\n        int index = int(floor(clamp(0.0, 11.0, frameIndex)));\\n        vec4 texColor;\\n        if(index == 0) texColor = texture2D(u_texFrame0, texCoord.xy);\\n        else if(index == 1) texColor = texture2D(u_texFrame1, texCoord.xy);\\n        else if(index == 2) texColor = texture2D(u_texFrame2, texCoord.xy);\\n        else if(index == 3) texColor = texture2D(u_texFrame3, texCoord.xy);\\n        else if(index == 4) texColor = texture2D(u_texFrame4, texCoord.xy);\\n        else if(index == 5) texColor = texture2D(u_texFrame5, texCoord.xy);\\n        else if(index == 6) texColor = texture2D(u_texFrame6, texCoord.xy);\\n        else if(index == 7) texColor = texture2D(u_texFrame7, texCoord.xy);\\n        else if(index == 8) texColor = texture2D(u_texFrame8, texCoord.xy);\\n        else if(index == 9) texColor = texture2D(u_texFrame9, texCoord.xy);\\n        else if(index == 10) texColor = texture2D(u_texFrame10, texCoord.xy);\\n        else texColor = texture2D(u_texFrame11, texCoord.xy);\\n        float alpha = texColor.a;\\n        if(opacity < 1.0) {\\n          texColor.a *= opacity;\\n          alpha *= mix(0.465, 1.0, opacity);\\n        }\\n        // color = mix(color, texColor, texColor.a);\\n        color.rgb = mix(color.rgb, texColor.rgb, alpha);\\n        // color.rgb = mix(texColor.rgb, color.rgb, color.a);\\n        color.rgb = mix(texColor.rgb, color.rgb, clamp(color.a / max(0.0001, texColor.a), 0.0, 1.0));\\n        color.a = texColor.a + (1.0 - texColor.a) * color.a;\\n      }\\n    }\\n  }\\n#endif\\n\\n#ifdef FILTER\\n  if(u_filterFlag > 0) {\\n    transformColor(color, u_colorMatrix);\\n  }\\n#endif\\n\\n#ifdef CLOUDFILTER\\n  float colorCloudMatrix[20];\\n  buildCloudColor(colorCloudMatrix);\\n  transformColor(color, colorCloudMatrix);\\n#endif\\n\\n#ifdef CLIPPATH\\n  float clip = texture2D(u_clipSampler, vClipUV).r;\\n  color *= clip;\\n#endif\\n\\n  gl_FragColor = color;\\n}\";"},"lineCount":null}},"error":null,"hash":"a7597f417294abf4f54a48688816fa07","cacheData":{"env":{}}}